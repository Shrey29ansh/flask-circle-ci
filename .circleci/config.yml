version: 2.1

orbs:
  python: circleci/python@2.1.1
  slack: circleci/slack@4.9.3
  aws-cli: circleci/aws-cli@2.0.3
  aws-ecr: circleci/aws-ecr@9.3.4
  docker: circleci/docker@1.7.0

parameters:
  org_name:
    type: string
    default: "inhouse"
  app_name:
    type: string
    default: "core-platform"
  build_path:
    type: string
    default: "."
  dockerfile_name:
    type: string
    default: "Dockerfile"
  extra_build_args:
    type: string
    default: ""
  dockerfile_path:
    type: string
    default: "docker"
  aws_profile:
    type: string
    default: "default"
  kms_key_id:
    type: string
    default: ""
commands:
  inject_variable:
    description: "This will make sure the persistant state is managed"
    parameters:
      key:
        type: string
      value:
        type: string
    steps:
      - run: |
          echo "export <<parameters.key>>=<<parameters.value" >> $BASH_ENV
      - run: |
          echo "Key $key injected with $value"
          cp $BASH_ENV bash.env
      - persist_to_workspace:
          root: .
          paths:
            - bash.env
  load_variables:
    description: "This will provide the shared environment variables"
    steps:
      - attach_workspace:
          at: .
      - run: |
          cat bash.env >> $BASH_ENV
  success-slack:
    description: "This is dynamic slack notification to use when an event is success only."
    steps:
      - slack/notify:
          event: pass
          template: success_tagged_deploy_1
  failure-slack:
    description: "This is dynamic slack notification to use when an event is success only."
    steps:
      - slack/notify:
          event: fail
          template: basic_fail_1
  slack-notification-customized:
    description: "This is dynamic slack notification to use."
    parameters:
      message:
        type: string
        default: "Circle CI Job started for project ${CIRCLE_PROJECT_REPONAME} on ${CIRCLE_BRANCH} branch"
    steps:
      - slack/notify:
          custom: |
            {
              "blocks": [
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "plain_text",
                      "text": "<<parameters.message>>",
                      "emoji": true
                    }
                  ]
                }
              ]
            }

jobs:
  aws-setup:
    executor: aws-cli/default
    working_directory: ~/application
    steps:
      - aws-cli/setup:
          profile-name: default
      - persist_to_workspace:
          root: ~/application
          paths:
            - .
      - run: 
          # Running this sample commmand to  Check if everything is working fine.
          command: | 
            aws sts get-caller-identity
  docker-build-and-push:
    parameters:
      ecr_repo_name:
        type: string
        default: <<pipeline.parameters.app_name>>
      docker_image_tag:
        type: string
        default: ${CIRCLE_BRANCH}-${CIRCLE_SHA1}-${CIRCLE_BUILD_NUM}
      aws_profile:
        type: string
        default: default
    executor:
      name: aws-ecr/default
    working_directory: ~/application
    steps:
      - checkout
      - run:
          command: |
            aws --version
            jq --version
      - docker/build:
          debug: false 
          docker-context: <<pipeline.parameters.build_path>> 
          dockerfile: <<pipeline.parameters.dockerfile_name>> 
          extra_build_args: <<pipeline.parameters.extra_build_args>> 
          path: <<pipeline.parameters.dockerfile_path>> 
          lint-dockerfile: false 
          image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/<<parameters.ecr_repo_name>> 
          tag: <<parameters.docker_image_tag>>
          treat-warnings-as-errors: false 
      - run:
          command: | 
            echo "Docker Image built with tag ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/<<pipeline.parameters.app_name>>:${CIRCLE_BRANCH}-${CIRCLE_SHA1}-${CIRCLE_BUILD_NUM}"
      - aws-ecr/ecr_login:
          public_registry: false 
          use_credentials_helper: true 
          profile_name: <<parameters.aws_profile>>
      - aws-ecr/push_image:
          public_registry: false 
          repo: <<parameters.ecr_repo_name>> 
          tag: <<parameters.docker_image_tag>>
  set-ecs-variables:
    executor:
      name: aws-ecr/default
    steps:
      - inject_variable:
          key: "TESTING"
          value: "<<pipeline.parameters.app_name>>"
  deploy-ecs-service:
    parameters:
      deploy:
        type: boolean
        default: false
      ecr_repo_name:
        type: string
        default: <<pipeline.parameters.app_name>> 
      docker_image_tag:
        type: string
        default: ${CIRCLE_BRANCH}-${CIRCLE_SHA1}-${CIRCLE_BUILD_NUM}
      deploy_environment: 
        type: string
        default: dev
      task_definition_name:
        type: string
        default: <<pipeline.parameters.app_name>>-<<parameters.deploy_environment>>-td
      ecs_service_name:
        type: string
        default: <<pipeline.parameters.app_name>>
      ecs_cluster_name:
        type: string
        default: <<pipeline.parameters.org_name>>-<<parameters.deploy_environment>>-cluster
    executor:
      name: aws-ecr/default
    working_directory: ~/application
    steps:
      - load_variables
      - run:
          environment:
            TASK_DEFINITION: <<parameters.task_definition_name>> # <<pipeline.parameters.app_name>>-<<parameter.deploy_environment>>-td 
          command: |
            printenv
            ECS_DEPLOY=<<parameters.deploy>>
            if [[ "${ECS_DEPLOY}" == "true" ]]; then 
              echo "<<parameters.ecs_cluster_name>>"
              echo "⛳️ Stage: Update"
              export RELEASE_IMAGE_NAME="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/<<parameters.ecr_repo_name>>:<<parameters.docker_image_tag>>"
              export IMAGE_NAME="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/<<parameters.ecr_repo_name>>"
              aws ecs describe-task-definition --task-definition ${TASK_DEFINITION} > TASK_DEFINITION.json
              cat TASK_DEFINITION.json
              echo "${IMAGE_NAME} ${RELEASE_IMAGE_NAME}"
              jq --arg NEW_IMAGE_NAME "${RELEASE_IMAGE_NAME}" --arg SEARCH_ECR_NAME "${IMAGE_NAME}" '.taskDefinition.containerDefinitions[] | (select(.image|contains($SEARCH_ECR_NAME)) | .image |= $NEW_IMAGE_NAME)' TASK_DEFINITION.json > raw_task_definition.txt
              jq --slurpfile CONTAINER_DEFINITION raw_task_definition.txt --arg SEARCH_ECR_NAME "${IMAGE_NAME}" '.taskDefinition | del(.containerDefinitions[] | (select(.image|contains($SEARCH_ECR_NAME)))) |  .containerDefinitions += $CONTAINER_DEFINITION | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' TASK_DEFINITION.json > FINAL_TASK_DEFINTIION.json
              aws ecs register-task-definition --family $TASK_DEFINITION --network-mode awsvpc --region=${AWS_DEFAULT_REGION} --cli-input-json file://FINAL_TASK_DEFINTIION.json 2>&1 > /dev/null
              LATEST_TD=$(aws ecs describe-task-definition --task-definition ${TASK_DEFINITION} | jq -cr '.taskDefinition.taskDefinitionArn | split("/") | last')
              echo "Latest Task definition is -> $LATEST_TD "
              aws ecs update-service --service <<parameters.ecs_service_name>> --cluster <<parameters.ecs_cluster_name>> --task-definition ${LATEST_TD} --force-new-deployment | jq '.service.deployments[] | (select(.status=="PRIMARY")) | del(.createdAt) | del(.networkConfiguration) | del(.platformFamily) | del(.desiredCount) | del(.runningCount) | del(.failedTasks) | del(.pendingCount)' > ECS_SERVICE.json
            else
              echo "Deployment flag is not true. Skipping Deployment"
  test:
    docker:
      - image: cimg/python:3.12
    steps:
      - checkout
      - python/install-packages:
          pkg-manager: poetry
          args: --no-root
      - run: 
          command: |
            poetry run pytest --version
            poetry run black src tests --check
            poetry run isort src tests --check
      - run:
          when: on_fail
          name: Add Comment to PR
          command: |
            export PULL_REQUEST_NUMBER=$(echo "${CI_PULL_REQUEST}" | awk -F"/" '{print $7}')
            printenv
            curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${GITHUB_COMMENT_PERSONAL_TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/issues/${PULL_REQUEST_NUMBER}/comments \
            -d '{"body":"Oops! This Pull Request is failed while running test cases. Please check the details."}'
      - run:
          name: Testing done
          command: echo "Testing is complete....."

  deploy-to-dev:
    docker:
      - image: cimg/python:3.12
    steps:
      - run:
          name: Printenvs
          command: |
            echo "ECS Deployment to dev environment for developer testing"
            
  deploy-to-staging:
    docker:
      - image: cimg/python:3.12
    steps:
      - run:
          name: Printenvs
          command: |
            echo "ECS Deployment to staging environment for QA testing"
  deploy-to-production:
    docker:
      - image: cimg/python:3.12
    steps:
      - run:
          name: Printenvs
          command: |
            echo "ECS Deployment to production environment."

  post-production:
    docker:
      - image: 'cimg/base:stable'
    steps:
      - success-slack
      - failure-slack

  notify: 
    parameters:
      message:
        type: string
        default: "Circle CI Job started for project ${CIRCLE_PROJECT_REPONAME} on ${CIRCLE_BRANCH} branch"
    docker:
      - image: 'cimg/base:stable'
    steps:
      - slack-notification-customized:
          message: "<<parameters.message>>"

  slack-notification:
    docker:
      - image: cimg/python:3.12
    steps:
      - run:
          name: slack-notification
          command: echo "Sending to slack"
      - run:
          name: slack-notification done
          command: echo "Notification done"

  waiter:
    docker:
      - image: cimg/python:3.12
    steps:
      - run: |
          while [[ $(curl --location --request GET "https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/job" --header "Circle-Token: $CCI_Token"| jq -r '.items[]|select(.name != "waiter")|.status' | grep -c "running") -gt 0 ]]
            do
              sleep 1
            done
      - run: echo "All required jobs have now completed"

workflows:
  version: 2
  pr-workflow:
    jobs:
      - notify:
          context: slack-secrets
      - test:
          requires:
            - notify
          filters:
            branches:
              only:
                - dev
                - staging
                - main 
      - docker-build-and-push:
          context: AWS
      - deploy-ecs-service:
          name: dev-environment-deployment
          deploy: true
          deploy_environment: dev
          ecr_repo_name: mvp
          task_definition_name: mvp-dev-td
          ecs_service_name: inhouse-core-platform
          requires: 
            - docker-build-and-push
          context: AWS
      - slack/on-hold:
          name: send-staging-approval-slack-notification
          context: slack-secrets
          requires:
            - dev-environment-deployment
      - staging-approval:
          type: approval
          requires:
            - send-staging-approval-slack-notification
      - docker-retag-push:
          context: AWS
          requires: 
            - staging-approval
      - deploy-ecs-service:
          name: staging-environment-deployment
          deploy_environment: staging
          ecr_repo_name: mvp
          task_definition_name: mvp-dev-td
          ecs_service_name: inhouse-core-platform
          ecs_cluster_name: inhouse-dev-cluster
          context: AWS
          requires:
            - docker-build-and-push
      # - slack/on-hold:
      #     name: send-production-approval-slack-notification
      #     context: slack-secrets
      #     requires:
      #       - deploy-to-dev
      # - production-approval:
      #     type: approval
      #     requires:
      #       - send-production-approval-slack-notification
      # - deploy-to-production:
      #     requires:
      #       - production-approval
      # - post-production:
      #     context: slack-secrets
      #     requires:
      #       - deploy-to-production
      # - aws-setup:
      #     context: AWS